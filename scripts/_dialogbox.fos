#ifndef __DIALOG_BOX__
	#define __DIALOG_BOX__
	shared interface iDialogBox
	{
		string name();
		bool OpenChild(string& name, iMenuHandler& handler);

		//Кнопка выбора использования предмета PID. Если предмета нет - нажатие ничего не делает.
		bool ButtonCheck(Critter& cr, int PID);

		//Кнопка с надписью из строки line файла FOTEXT.MSG
		bool ButtonMsg(int line);

		//Кнопка с надписью из строки line файла FOTEXT.MSG и лексемой lexems
		bool ButtonMsg(int line, string@ lexems);
		
		//Кнопка с надписью из строки line файла file
		bool ButtonMsg(int file, int line);

		//Кнопка с надписью из строки line файла file и лексемой lexems
		bool ButtonMsg(int file, int line, string@ lexems);

		// Простая кнопка с надписью
		// text - надпись на кнопке
		bool Button(string& text);

		// Кнопка с надписью, которая вызывает окно для ввода текста
		// say - надпись на окне ввода текста
		bool ButtonSay(string& text, string@ say);

		//Кнопка с надписью из строки line файла FOTEXT.MSG и окном для ввода текста, содержащим say_line
		bool ButtonSayMsg(int line, int say_line);
		
		//Кнопка с надписью из строки line файла FOTEXT.MSG и лексемой ext, открывающую окно для ввода текста содержащее say_line
		bool ButtonSayMsg(int line, string@ ext, int say_line);

		// Кнопка с надписью состоящей из двух частей: статичной и динамичной.
		// ext - динамичная часть надписи
		bool ButtonExt(string& text, string@ ext);

		// Кнопка с надписью состоящей из двух частей, которая вызывает окно для ввода текста.
		bool ButtonExtSay(string& text, string@ ext, string@ say);

		// Кнопка с полностью настраиваемыми данными - на выбор либо строка из файла, либо кастомный текст. Данная кнопка так же вызывает окно для ввода текста и подписью say_line($lex say@)
		bool ButtonExtSay(string& text, int file, int line, string@ ext, string@ say, int say_line);

		// Получить значение из окна для ввода текста. Следует вызывать только сразу после того как ButtonSay или ButtonExtSay вернули true.
		string@ GetSayValue();
		
		//Остановить отрисовку для обработки всплывающего окна. Контроль к меню возвращается через вызов RestoreMenu(cr)
		bool DelayRedraw();
	}

	shared interface iMenuHandler
	{
		bool MenuUpdate(Critter& cr, iDialogBox& menu);
		string@ Description(Critter& cr);
		int getDescriptionFile();
		int getDescriptionLine();
		string@ ButtonDecorator(string& text, string@ ext);
		string@ ButtonNextPage(int page_current, int page_last);
		string@ ButtonPrevPage(int page_current, int page_last);
		string@ ButtonCancel();
		void OnMenuDraw(Critter& cr);
		void OnError(Critter& cr, string& text, string@ ext);
		bool ShouldRedraw(Critter& cr);
	}

	#ifndef __SUCK_LESS__
	import iDialogBox@ OpenMenu(Critter& cr, string& name, iMenuHandler& handler) from "suck_less";
	import bool RestoreMenu(Critter& cr) from "suck_less";
	import void enlistKeys(Critter& cr) from "suck_less";
	import string DebugMenu(Critter& cr) from "suck_less";

	class DefaultMenuHandler: iMenuHandler
	{
		bool MenuUpdate(Critter& cr, iDialogBox& menu)
		{
			return false;
		}
		string@ Description(Critter& cr)
		{
			return null;
		}
		int getDescriptionFile()
		{
			return -1;
		}
		int getDescriptionLine()
		{
			return 0;
		}
		string@ ButtonDecorator(string& text, string@ ext)
		{
			if(ext is null)
			{
				return text;
			}
			else
			{
				return text + ext;
			}
		}
		string@ ButtonNextPage(int page_current, int page_last)
		{
			int human_readable = (page_current+1)%(page_last+1) + 1;
			return ButtonDecorator("Page " + human_readable + " ->", null);
		}
		string@ ButtonPrevPage(int page_current, int page_last)
		{
			int human_readable = (page_current+page_last)%(page_last+1) + 1;
			return ButtonDecorator("<- Page " + human_readable, null);
		}
		string@ ButtonCancel()
		{
			return null;
		}
		
		void OnMenuDraw(Critter& cr)
		{
		}
		
		void OnError(Critter& cr, string& text, string@ ext)
		{
			cr.Say(SAY_NETMSG, "Can't comply \""+text+"\"");
		}
		
		bool ShouldRedraw(Critter& cr)
		{
			return false;
		}
	}

	class CenteredMenuHandler: DefaultMenuHandler
	{
		string@ ButtonDecorator(string& text, string@ ext)
		{
			string@ full_text;
			if(ext is null)
			{
				@full_text = text;
			}
			else
			{
				@full_text = text + ext;
			}

			if(full_text.length() > 16)
			{
				return full_text;
			}
			return substring("                  ", 0, 18-full_text.length()) + full_text;
		}
	}

	#endif

#endif

